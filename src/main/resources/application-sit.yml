server:
  context-path: /app
  port: 12070

spring:
  freemarker:
    # 设置模板后缀名
    suffix: .ftl
    # 设置文档类型
    content-type: text/html
    # 设置页面编码格式
    charset: UTF-8
    # 设置页面缓存
    cache: false
    # 设置ftl文件路径
    template-loader-path:
      - classpath:/templates
    # 设置静态文件路径，js,css等
    mvc:
      static-path-pattern: /static/**
  datasource:
    dynamic:
      # druid连接池设置
      druid:
        #     配置初始化大小、最小、最大线程数
        initialSize: 5
        minIdle: 5
        #     CPU核数+1，也可以大些但不要超过20，数据库加锁时连接过多性能下降
        maxActive: 20
        #     最大等待时间，内网：800，外网：1200（三次握手1s）
        maxWait: 60000
        timeBetweenEvictionRunsMillis: 60000
        #     配置一个连接在池中最大空间时间，单位是毫秒
        minEvictableIdleTimeMillis: 300000
        validationQuery: SELECT 1
        testWhileIdle: true
        #     设置从连接池获取连接时是否检查连接有效性，true检查，false不检查
        testOnBorrow: true
        #     设置从连接池归还连接时是否检查连接有效性，true检查，false不检查
        testOnReturn: true
        #     可以支持PSCache（提升写入、查询效率）
        poolPreparedStatements: true
        #   配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
        filters: stat
        #     保持长连接
        keepAlive: true
        maxPoolPreparedStatementPerConnectionSize: 20
        useGlobalDataSourceStat: true
        connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# druid连接池设置
      primary: master #设置默认的数据源或者数据源组,默认值即为master
      strict: false #严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源
      datasource:
        master:
          type: com.alibaba.druid.pool.DruidDataSource
          url: jdbc:mysql://localhost:5306/promotion?autoReconnect=true&useUnicode=true&characterEncoding=utf8&allowMultiQueries=true&serverTimezone=UTC&useSSL=false&connectTimeout=1000&socketTimeout=3000
          username: root
          password: root
          driver-class-name: com.mysql.cj.jdbc.Driver

        custer:
          type: com.alibaba.druid.pool.DruidDataSource
          url: jdbc:mysql://localhost:5306/dcp_framework?autoReconnect=true&useUnicode=true&characterEncoding=utf8&allowMultiQueries=true&serverTimezone=UTC&useSSL=false&connectTimeout=1000&socketTimeout=3000
          username: root
          password: root
          driver-class-name: com.mysql.cj.jdbc.Driver
    druid:
      # 关闭过滤器,影响单元测试
      web-stat-filter:
        enabled: false


  jackson:
    date-format: yyyy-MM-dd HH:mm:ss
    time-zone: GMT+0
  cache:
    type: redis
  redis:
    host: 127.0.0.1
    port: 6379
    database: 0
    # 客户端超时时间单位是毫秒
    timeout: 60s
    password:
    jedis:
      pool:
        maxActive: 10
        maxIdle: 10
        minIdle: 5
        #连接池最大等行时间 -1没有限制
        maxWait: 60s
        # 逐出扫描的时间间隔
        timeBetweenEvictionRuns: 60s

  kafka:
    # 服务器地址,多个逗号隔开
    bootstrap-servers: 127.0.0.1:9092
    # producer 生产者
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      # 批量大小
      batch-size: 16384
      # 应答级别:多少个分区副本备份完成时向生产者发送ack确认(可选0、1、all/-1)
      acks: 1
      # 重试次数
      retries: 1
      properties:
        # 提交延时(
        ## 当生产端积累的消息达到batch-size或接收到消息linger.ms后,生产者就会将消息提交给kafka
        ## linger.ms为0表示每接收到一条消息就提交给kafka,这时候batch-size其实就没用了)
        linger.ms: 0
        # 自定义分区器
        partitioner.class: com.org.dream.config.kafka.CustomizePartitioner
      # 生产端缓冲区大小
      buffer-memory: 33554432
      # 事务前缀
      transaction-id-prefix: app_tx_
    # consumer消费者
    consumer:
      # 默认的消费组ID
      group-id: dream-group
      # 是否自动提交offset
      enable-auto-commit: true
      # 提交offset延时(接收到消息后多久提交offset)
      auto-commit-interval: 100s
      # earliest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，从头开始消费
      # latest:当各分区下有已提交的offset时，从提交的offset开始消费；无提交的offset时，消费新产生的该分区下的数据
      # none:topic各分区都存在已提交的offset时，从offset后开始消费；只要有一个分区不存在已提交的offset，则抛出异常
      auto-offset-reset: latest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      #一次批量处理的数据量
      max-poll-records: 100
      # 获取消息最大等待时间
      fetch-max-wait: 60s
      properties:
        # 消费会话超时时间(超过这个时间consumer没有发送心跳,就会触发rebalance操作)
        session:
          timeout:
            ms: 120000
        # 消费请求超时时间
        request:
          timeout:
            ms: 180000
    listener:
      # 线程消费数量
      concurrency: 3
      # 消费端监听的topic不存在时，项目启动会报错(关掉)
      missing-topics-fatal: false
      # 批量消费每次最多消费多少条消息
      max-poll-records: 50
      # 单个或批量消费(batch、single)
      type: single
      pollTimeout: 60s

logging:
  config: classpath:logback-spring.xml
  level:
    #日志级别
    root: info
    com.org.dream.dao: debug
    #RestTemplate请求debug日志级别
    org.springframework.web.client.RestTemplate: debug
  file:
    logName: app-service-log
    config-max-history: 10
    config-max-size: 10MB

spring.main.allow-bean-definition-overriding: true

mybatis-plus:
  #MyBatis Mapper 所对应的 XML 文件位置，如果您在 Mapper 中有自定义方法（XML 中有自定义实现），需要进行该配置，告诉 Mapper 所对应的 XML 文件位置。
  #mapper-locations: classpath*:mapper/**/*.xml
  mapper-locations: classpath:/mapper/*.xml
  #单独的 MyBatis 配置，请将其路径配置到 configLocation 中  注意 configuration与config-location不能一起用
  #config-location: classpath*:mybatis-config.xml
  # 实体对象的扫描包,MyBaits 别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.org.dream.domain.entity
  #枚举对象的扫描包,等价：default-enum-type-handler: com.baomidou.mybatisplus.extension.handlers.MybatisEnumTypeHandler
  type-enums-package: com.org.dream.domain.enums
  configuration:
    # 禁用缓存
    cache-enabled: false
    # call-setters-on-nulls: true
    # jdbc-type-for-null: 'null'
    #开启映射时驼峰命名, 开启后不需要写字段映射@TableField
    map-underscore-to-camel-case: true
    #开启控制台 SQL 日志打印
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    auto-mapping-behavior: full
    default-enum-type-handler: com.baomidou.mybatisplus.extension.handlers.MybatisEnumTypeHandler
  global-config:
    db-config:
      #全局默认主键类型，设置后，即可省略实体对象中的@TableId(type = IdType.AUTO)配置
      id-type: auto
      #表名前缀，全局配置后可省略 @TableName()配置。默认值：null
      # table-prefix: tb_
      # !=null and !='' 才更新, 相反可使用@TableField(updateStrategy = FieldStrategy.IGNORED)
      update-strategy: not_empty
      # !=null and !='' 才插入, 相反可使用@TableField(updateStrategy = FieldStrategy.IGNORED)
      insert-strategy: not_empty
      # 逻辑删除值
      #logic-delete-value: 0
      #logic-not-delete-value: 1
    banner: true

pagehelper:
  helper-dialect: mysql
  reasonable: true
  support-methods-arguments: true

#　是否启动xxl-job
xxl.job.enabled: false

http:
  #最大连接数
  maxTotal: 100
  #并发数
  defaultMaxPerRoute: 20
  #创建连接的最长时间
  connectTimeout: 1000
  #从连接池中获取到连接的最长时间
  connectionRequestTimeout: 500
  #数据传输的最长时间
  socketTimeout: 10000
  #提交请求前测试连接是否可用
  staleConnectionCheckEnabled: true
  #可用空闲连接过期时间,重用空闲连接时会先检查是否空闲时间超过这个时间，如果超过，释放socket重新建立
  validateAfterInactivity: 3000000

# 企业微信配置
wei-xin:
  # 获取token地址
  token-url: https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid={0}&corpsecret={1}
  # 发送应用消息地址
  send-msg-url: https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token={0}
  # 企业ID
  appId: ww27117c0555d72370
  # 密钥
  appSecret: dFb8Nv8GTLf74ozsakPedvWEPEaiFWIfb5mGE31xsRs